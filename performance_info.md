## 各PHP実行環境情報

# 共通環境情報

### アプリケーション基盤
共通項目
- **PHP**: 8.3.20
- **データベース**: MySQL 8.0
- **コンテナ**: Docker + Docker Compose
- **監視**: OpenTelemetry (Jaeger)

### Apache + mod_php, Nginx + php-fpm
Laravel 12

### Swoole + Nginx, FrankenPHP
Laravel Octone

# 計測項目
- CPU使用率
- メモリ使用量
- PHPプロセス
- スループット
- レスポンスタイム

## 比較検証のポイント

1. **レスポンス時間**: 同一負荷での応答速度比較
2. **スループット**: 単位時間あたりの処理能力
3. **メモリ使用量**: 各構成でのメモリ効率
4. **CPU使用率**: 処理負荷による CPU 消費
5. **同時接続数**: 最大同時接続処理能力
6. **エラー率**: 高負荷時のエラー発生率


# 計測ツール
OpenTelemetry
k6

OpenTelemetryを選んだ理由はこちら
https://zenn.dev/booost/articles/a691d0fe7aeae6
ZTS環境に対応したプロファイリングツールが少ない…


# 計測しない項目
- ブラウザレンダリング
PHPはWebAPIサーバーとして振る舞うことが多いため

# テストシナリオ
記事投稿 + 記事取得

ER図を挿入

順序だて
- 50件で比較ランキング発表
- スパイクテストランキング発表
  - 何処までいけるのか
   swoole、frankenphp

パフォーマンスが出ないアンチパターン
opecacheを利用していない
検証データを出す
全部の環境で大幅に劣化
opecacheなしのfrankenphp 
opecacheありのapache

本番環境ではopecacheを利用しましょう

apacheの例
全てが3分の１
CPU、メモリ、パーセンタイル

frankenphp特有
laravel octonを使わない
workerモードを使わない
caddry から立ち上げる

すぐに劣化する！


---

ランキングのあと
Frankenが最適解？
そんなことはない
ケースによる

Read < Write（書き込み中心）の場合
Read > Write（読み込み中心）の場合
こっちだよの話
あとバッチ処理
当たり前だけれど、Webサーバー関係ない
素のPHPの設定値勝負！

opcacheを利かせる！

opcacheの偉大さ
Apacheではこんな差が出る
CPUとメモリ消費量が1/5



今回の４環境で
チューニングしやすさ
速度の潜在性
の2軸グラフ作る
swooleは端っこ


## Read < Write（書き込み中心）の場合

**特徴：**
- データベースへの書き込み処理がボトルネックになりやすい
- トランザクション処理やロック待ちが発生
- Webサーバーの違いによる影響は相対的に小さい

**理由：**
- 書き込み処理はキャッシュが効きにくい
- DBのI/O性能やトランザクション処理能力が全体のパフォーマンスを左右
- Apache、Nginx、LiteSpeedなどWebサーバーの違いは大きな差にならない

## Read > Write（読み込み中心）の場合

**特徴：**
- Webサーバーの性能差が顕著に現れる
- 静的コンテンツの配信効率が重要
- キャッシュ戦略が大きく影響

**Webサーバーによる違い：**

**Apache + mod_php**
- プロセスベースで安定性は高いがメモリ消費大
- 同時接続数が多いと性能低下

**Nginx + PHP-FPM**
- イベント駆動で高速な静的ファイル配信
- リバースプロキシとして優秀
- 大量の同時接続に強い

**LiteSpeed**
- LSAPIによる高速なPHP実行
- 内蔵キャッシュ機能が強力
- 商用ライセンスが必要

**その他の考慮点：**
- OPcacheの活用
- CDNの導入
- Redisやmemcachedなどのキャッシュレイヤー
- 静的ファイルの最適化

このように、アプリケーションの特性に応じて適切な実行環境を選択することが重要ですね。